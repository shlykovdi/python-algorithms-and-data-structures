https://github.com/shlykovdi/python-algorithms-and-data-structures/pull/4

1. В первом задании я реализовывал алгоритм из 1 задания 3 лекции. 
"В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9"

Лучшим оказался обычный алгоритм перебора числе (такой как impl_1), но разогнанный через @jit компилятор с распараллеливанием задач. В прикрепленном изображении result.png можно увидеть графики времени выполнения алгоритмов. impl_3 задействовал все 16 потоков процессора и отработал очень быстро.

impl_2 - это скорее баловство, чтобы удовлетворить условиям задачи.

Замеры времени проводились ни через timeit и не cProfile, а собственным методом. Это необходимо чтобы уравнять шансы и условия тестирования, потому что задействуется jit компилятор и не совсем понятно как именно он себя поведет с тем же timeit. Рисковать я не стал для чистоты эксперимента.

Сложность всех алгоритмов O(n).

2. Во втором задании выигрывает по быстродействию решето эратосфена - sieve. Сложность данного оптимизированного алгоритма O(n * log(log(n))), судя по википедии.
Второй алгоритм - prime. Какая сложность будет у него я затрудняюсь сказать. Но судя по графику время расчета очередного числа постепенно растет, чем больше мы запрашиваем индекс.
